<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Flight Routes App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            /* Flexbox for centering is now handled by Tailwind classes on body */
        }
        /* Custom styles that Tailwind doesn't directly provide or for specific overrides */
        .output-section {
            background-color: #e2e8f0; /* bg-gray-200 */
            border: none; /* Remove default border as it's part of the outer container */
        }
        #output {
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            font-family: monospace;
            flex-grow: 1; /* Allow output to grow and fill available space */
            overflow-y: auto; /* Enable scrolling for long output */
            min-height: 200px; /* Minimum height for output area */
        }
        /* Further refined button hover effects for better feel */
        button:hover {
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); /* Add subtle shadow on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }
        button {
            transition: all 0.2s ease-in-out; /* Smooth transitions for hover effects */
        }
    </style>
</head>
<body class="flex justify-center items-start min-h-screen p-4 sm:p-6 md:p-8">
    <div class="container bg-white rounded-xl shadow-xl p-6 sm:p-8 w-full max-w-4xl
                grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-gray-900 mb-6 col-span-full">
            ✈️ Global Flight Routes App
        </h1>

        <div class="input-section bg-blue-50 border border-blue-200 rounded-lg p-4 sm:p-6
                    flex flex-col shadow-md">
            <h2 class="section-title text-xl sm:text-2xl font-bold text-gray-800 mb-4 text-center">Flight Query</h2>
            <label for="sourceAirport" class="block mb-2 font-semibold text-gray-700 text-base sm:text-lg">Source Airport:</label>
            <select id="sourceAirport" class="w-full p-2 sm:p-3 mb-4 border border-gray-300 rounded-md text-base
                                            focus:ring-blue-500 focus:border-blue-500 transition duration-150"></select>

            <label for="destinationAirport" class="block mb-2 font-semibold text-gray-700 text-base sm:text-lg">Destination Airport:</label>
            <select id="destinationAirport" class="w-full p-2 sm:p-3 mb-6 border border-gray-300 rounded-md text-base
                                            focus:ring-blue-500 focus:border-blue-500 transition duration-150"></select>

            <button class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg
                           hover:bg-blue-700 shadow-md mb-3 text-base sm:text-lg"
                    onclick="getShortestDistanceValue()">Get Shortest Distance (KM)</button>
            <button class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg
                           hover:bg-blue-700 shadow-md mb-3 text-base sm:text-lg"
                    onclick="getShortestTimeValue()">Get Shortest Time (Minutes)</button>
            <button class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg
                           hover:bg-blue-700 shadow-md mb-3 text-base sm:text-lg"
                    onclick="getShortestDistancePath()">Get Shortest Path (Distance Wise)</button>
            <button class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg
                           hover:bg-blue-700 shadow-md mb-6 text-base sm:text-lg"
                    onclick="getShortestTimePath()">Get Shortest Path (Time Wise)</button>

            <button class="w-full py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg
                           hover:bg-gray-600 shadow-md mb-3 text-base sm:text-lg"
                    onclick="displayAllAirports()">List All Airports</button>
            <button class="w-full py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg
                           hover:bg-gray-600 shadow-md text-base sm:text-lg"
                    onclick="displayMap()">Show Flight Map</button>
        </div>

        <div class="output-section bg-gray-100 rounded-lg p-4 sm:p-6
                    flex flex-col shadow-md">
            <h2 class="section-title text-xl sm:text-2xl font-bold text-gray-800 mb-4 text-center">Output</h2>
            <pre id="output" class="bg-white border border-gray-300 rounded-md p-3 text-sm md:text-base lg:text-lg text-gray-800"></pre>
        </div>
    </div>

    <script>
        // --- Core Data Structures & Algorithms (JavaScript Re-implementation) ---

        // Helper for Min-Heap implementation (DijkstraPair will be the type T)
        class Heap {
            constructor() {
                this.data = [];
                this.map = new Map(); // Using Map for direct object-to-index mapping
            }

            add(item) {
                this.data.push(item);
                this.map.set(item, this.data.length - 1);
                this.upheapify(this.data.length - 1);
            }

            upheapify(ci) {
                if (ci === 0) {
                    return;
                }
                let pi = Math.floor((ci - 1) / 2);
                if (this.data[ci].compareTo(this.data[pi]) < 0) {
                    this.swap(pi, ci);
                    this.upheapify(pi);
                }
            }

            swap(i, j) {
                let ith = this.data[i];
                let jth = this.data[j];

                this.data[i] = jth;
                this.data[j] = ith;

                this.map.set(ith, j);
                this.map.set(jth, i);
            }

            isEmpty() {
                return this.data.length === 0;
            }

            remove() {
                if (this.isEmpty()) {
                    throw new Error("Cannot remove from empty heap.");
                }
                this.swap(0, this.data.length - 1);
                let rv = this.data.pop();
                this.downheapify(0);

                this.map.delete(rv);
                return rv;
            }

            downheapify(pi) {
                let lci = 2 * pi + 1;
                let rci = 2 * pi + 2;
                let minIdx = pi;

                if (lci < this.data.length && this.data[lci].compareTo(this.data[minIdx]) < 0) {
                    minIdx = lci;
                }

                if (rci < this.data.length && this.data[rci].compareTo(this.data[minIdx]) < 0) {
                    minIdx = rci;
                }

                if (minIdx !== pi) {
                    this.swap(minIdx, pi);
                    this.downheapify(minIdx);
                }
            }

            peek() {
                if (this.isEmpty()) {
                    throw new Error("Cannot peek from empty heap.");
                }
                return this.data[0];
            }

            updatePriority(item) {
                let index = this.map.get(item);
                if (index === undefined) {
                    console.warn("Attempted to update priority for item not found in heap:", item);
                    return;
                }
                this.upheapify(index);
            }
        }

        // Represents a vertex (airport) in the graph
        class Vertex {
            constructor() {
                this.nbrs = new Map(); // Map of neighbors (airport name) to edge weight
            }
        }

        // Helper class for Dijkstra's algorithm
        // Defined outside Graph_M for better compatibility with older JS environments
        class DijkstraPair {
            constructor(vname, psf, cost) {
                this.vname = vname; // Vertex name (airport full name)
                this.psf = psf;     // Path so far (string)
                this.cost = cost;   // Accumulated cost
            }
            // For min-heap, A < B if A.cost < B.cost
            compareTo(other) {
                return this.cost - other.cost;
            }
        }

        // Represents the result of pathfinding
        // Defined outside Graph_M for better compatibility with older JS environments
        class PathResult {
            constructor(path, totalCost, interchangeCount) {
                this.path = path;
                this.totalCost = totalCost;
                this.interchangeCount = interchangeCount;
            }
        }


        // Represents the Graph itself
        class Graph_M {
            constructor() {
                this.vtces = new Map(); // Map of airport name to Vertex object
            }

            addVertex(vname) {
                if (!this.vtces.has(vname)) {
                    this.vtces.set(vname, new Vertex());
                }
            }

            addEdge(vname1, vname2, value) {
                if (!this.vtces.has(vname1) || !this.vtces.has(vname2)) {
                    // console.warn(`One or both vertices not found: ${vname1}, ${vname2}`);
                    return;
                }
                if (this.vtces.get(vname1).nbrs.has(vname2)) {
                    // console.warn(`Edge already exists between ${vname1} and ${vname2}`);
                    return;
                }
                this.vtces.get(vname1).nbrs.set(vname2, value);
                this.vtces.get(vname2).nbrs.set(vname1, value); // Undirected graph
            }


            // Dijkstra's algorithm re-implemented in JavaScript
            dijkstra(src, des, isTimeCost) {
                if (!this.vtces.has(src) || !this.vtces.has(des)) {
                    return new PathResult("INVALID_STATIONS", -1, 0); // Reference PathResult directly
                }

                let map = new Map(); // Stores DijkstraPair for each vertex
                let pq = new Heap(); // Min-Heap

                // Initialize all vertices
                for (let vname of this.vtces.keys()) {
                    let np = new DijkstraPair(vname, "", Number.MAX_SAFE_INTEGER); // Reference DijkstraPair directly
                    if (vname === src) {
                        np.cost = 0;
                        np.psf = vname; // Path starts with source
                    }
                    pq.add(np);
                    map.set(vname, np);
                }

                while (!pq.isEmpty()) {
                    let rp = pq.remove(); // Extract min cost pair

                    if (rp.vname === des) {
                        return new PathResult(rp.psf, rp.cost, 0); // Reference PathResult directly
                    }

                    if (!map.has(rp.vname)) { // Already processed with a shorter path
                        continue;
                    }

                    map.delete(rp.vname); // Mark as processed

                    let v = this.vtces.get(rp.vname);
                    for (let [nbr, edgeWeight] of v.nbrs.entries()) {
                        if (map.has(nbr)) { // Consider only unprocessed neighbors
                            let oldCost = map.get(nbr).cost;
                            let newCost;

                            if (isTimeCost) {
                                // Time cost = current accumulated time + 120 (fixed) + 40 * distance_unit
                                newCost = rp.cost + (120 + 40 * edgeWeight);
                            } else {
                                // Distance cost = current accumulated distance + edge distance
                                newCost = rp.cost + edgeWeight;
                            }

                            if (newCost < oldCost) {
                                let gp = map.get(nbr);
                                // CRITICAL FIX: Use a unique delimiter for path segments
                                gp.psf = rp.psf + "###" + nbr;
                                gp.cost = newCost;
                                pq.updatePriority(gp);
                            }
                        }
                    }
                }
                return new PathResult("NO_PATH", -1, 0); // Reference PathResult directly
            }

            // Processes raw path for display and interchanges
            processPathForDisplay(rawPathResult) {
                if (!rawPathResult || !rawPathResult.path || rawPathResult.path.length === 0 ||
                    rawPathResult.path === "NO_PATH" || rawPathResult.path === "INVALID_STATIONS") {
                    return rawPathResult;
                }

                // CRITICAL FIX: Split using the unique delimiter
                let stations = rawPathResult.path.split("###");

                if (stations.length === 0) {
                    return new PathResult("NO_PATH", -1, 0); // Reference PathResult directly
                }

                let formattedPathSegments = [stations[0]];
                let interchanges = 0;

                for (let i = 1; i < stations.length; i++) {
                    let currentStation = stations[i];
                    let prevStation = stations[i - 1];

                    let prevTildeIndex = prevStation.indexOf('~');
                    let currentTildeIndex = currentStation.indexOf('~');

                    if (prevTildeIndex === -1 || currentTildeIndex === -1) {
                        console.error("Error: Malformed airport name detected in path for display. Missing '~' separator.");
                        console.error(`Problematic segment: Previous Airport: '${prevStation}', Current Airport: '${currentStation}'`);
                        return new PathResult("PATH_FORMAT_ERROR", -1, 0); // Reference PathResult directly
                    }

                    let currentLineCode = currentStation.substring(0, currentTildeIndex);
                    let prevLineCode = prevStation.substring(0, prevTildeIndex);

                    if (currentLineCode !== prevLineCode) {
                        interchanges++;
                        formattedPathSegments.push(`CHANGE FROM ${prevLineCode} TO ${currentLineCode} LINE AT ${prevStation}`);
                    }
                    formattedPathSegments.push(currentStation);
                }

                let displayPath = `START ==> ${formattedPathSegments[0]}`;
                for (let i = 1; i < formattedPathSegments.length; i++) {
                    displayPath += `\n    ==> ${formattedPathSegments[i]}`;
                }
                displayPath += `\n    ==> END`;

                return new PathResult(displayPath, rawPathResult.totalCost, interchanges); // Reference PathResult directly
            }

            // Display all airports
            displayStations() {
                let output = "***********************************************************************\n\n";
                let keys = Array.from(this.vtces.keys());
                keys.forEach((key, index) => {
                    output += `${index + 1}. ${key}\n`;
                });
                output += "\n***********************************************************************";
                return output;
            }

            // Display map
            displayMap() {
                let output = "\n\t Flight Routes Map\n";
                output += "\t------------------\n";
                output += "----------------------------------------------------\n\n";
                
                for (let [key, vertex] of this.vtces.entries()) {
                    let str = `${key} =>\n`;
                    for (let [nbr, weight] of vertex.nbrs.entries()) {
                        str += `\t${nbr}\t`;
                        // Basic formatting for alignment (adjust as needed)
                        if (nbr.length < 16) str += "\t";
                        if (nbr.length < 8) str += "\t";
                        str += `${weight}\n`;
                    }
                    output += str;
                }
                output += "\t------------------\n";
                output += "---------------------------------------------------\n";
                return output;
            }

            // Populates the graph with flight routes (Indian focus)
            createFlightMap() {
                // Indian Airports
                this.addVertex("DEL~Indira Gandhi International Airport, Delhi");
                this.addVertex("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai");
                this.addVertex("BLR~Kempegowda International Airport, Bengaluru");
                this.addVertex("MAA~Chennai International Airport, Chennai");
                this.addVertex("CCU~Netaji Subhas Chandra Bose International Airport, Kolkata");
                this.addVertex("HYD~Rajiv Gandhi International Airport, Hyderabad");
                this.addVertex("AMD~Sardar Vallabhbhai Patel International Airport, Ahmedabad");
                this.addVertex("PNQ~Pune Airport, Pune");
                this.addVertex("GOI~Goa International Airport (Dabolim), Goa");
                this.addVertex("COK~Cochin International Airport, Kochi");
                this.addVertex("JAI~Jaipur International Airport, Jaipur");
                this.addVertex("LKO~Chaudhary Charan Singh International Airport, Lucknow");
                this.addVertex("ATQ~Sri Guru Ram Dass Jee International Airport, Amritsar");

                // Essential International Hubs (connected from India)
                this.addVertex("LHR~Heathrow Airport, London");
                this.addVertex("DXB~Dubai International Airport, Dubai");
                this.addVertex("SIN~Changi Airport, Singapore");
                this.addVertex("JFK~John F. Kennedy International Airport, New York");
                this.addVertex("CDG~Charles de Gaulle Airport, Paris");
                this.addVertex("AUH~Abu Dhabi International Airport, Abu Dhabi");
                this.addVertex("HKG~Hong Kong International Airport, Hong Kong");


                // --- Domestic Indian Flight Routes (weights are 'distance units' for simplicity) ---
                // Delhi (DEL) connections
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", 120); // ~2 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "BLR~Kempegowda International Airport, Bengaluru", 150); // ~2.5 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "MAA~Chennai International Airport, Chennai", 160); // ~2.7 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "CCU~Netaji Subhas Chandra Bose International Airport, Kolkata", 120); // ~2 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "HYD~Rajiv Gandhi International Airport, Hyderabad", 100); // ~1.7 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "AMD~Sardar Vallabhbhai Patel International Airport, Ahmedabad", 90); // ~1.5 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "JAI~Jaipur International Airport, Jaipur", 60); // ~1 hr
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "LKO~Chaudhary Charan Singh International Airport, Lucknow", 70); // ~1.2 hrs
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "ATQ~Sri Guru Ram Dass Jee International Airport, Amritsar", 70); // ~1.2 hrs

                // Mumbai (BOM) connections
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "BLR~Kempegowda International Airport, Bengaluru", 90); // ~1.5 hrs
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "MAA~Chennai International Airport, Chennai", 100); // ~1.7 hrs
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "HYD~Rajiv Gandhi International Airport, Hyderabad", 70); // ~1.2 hrs
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "PNQ~Pune Airport, Pune", 30); // ~0.5 hrs
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "GOI~Goa International Airport (Dabolim), Goa", 70); // ~1.2 hrs
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "AMD~Sardar Vallabhbhai Patel International Airport, Ahmedabad", 70); // ~1.2 hrs

                // Bengaluru (BLR) connections
                this.addEdge("BLR~Kempegowda International Airport, Bengaluru", "MAA~Chennai International Airport, Chennai", 60); // ~1 hr
                this.addEdge("BLR~Kempegowda International Airport, Bengaluru", "HYD~Rajiv Gandhi International Airport, Hyderabad", 60); // ~1 hr
                this.addEdge("BLR~Kempegowda International Airport, Bengaluru", "COK~Cochin International Airport, Kochi", 70); // ~1.2 hrs
                this.addEdge("BLR~Kempegowda International Airport, Bengaluru", "GOI~Goa International Airport (Dabolim), Goa", 60); // ~1 hr

                // Chennai (MAA) connections
                this.addEdge("MAA~Chennai International Airport, Chennai", "HYD~Rajiv Gandhi International Airport, Hyderabad", 75); // ~1.25 hrs
                this.addEdge("MAA~Chennai International Airport, Chennai", "COK~Cochin International Airport, Kochi", 80); // ~1.3 hrs

                // Kolkata (CCU) connections
                this.addEdge("CCU~Netaji Subhas Chandra Bose International Airport, Kolkata", "HYD~Rajiv Gandhi International Airport, Hyderabad", 120); // ~2 hrs
                this.addEdge("CCU~Netaji Subhas Chandra Bose International Airport, Kolkata", "BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", 150); // ~2.5 hrs

                // Other domestic connections
                this.addEdge("HYD~Rajiv Gandhi International Airport, Hyderabad", "GOI~Goa International Airport (Dabolim), Goa", 80); // ~1.3 hrs
                this.addEdge("PNQ~Pune Airport, Pune", "GOI~Goa International Airport (Dabolim), Goa", 60); // ~1 hr


                // --- Key International Connections (from major Indian cities) ---
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "LHR~Heathrow Airport, London", 600);
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "DXB~Dubai International Airport, Dubai", 200);
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "SIN~Changi Airport, Singapore", 380);
                this.addEdge("BLR~Kempegowda International Airport, Bengaluru", "SIN~Changi Airport, Singapore", 300);
                this.addEdge("DEL~Indira Gandhi International Airport, Delhi", "JFK~John F. Kennedy International Airport, New York", 800);
                this.addEdge("BOM~Chhatrapati Shivaji Maharaj International Airport, Mumbai", "CDG~Charles de Gaulle Airport, Paris", 650);
                this.addEdge("HYD~Rajiv Gandhi International Airport, Hyderabad", "AUH~Abu Dhabi International Airport, Abu Dhabi", 250);
                this.addEdge("CCU~Netaji Subhas Chandra Bose International Airport, Kolkata", "HKG~Hong Kong International Airport, Hong Kong", 320);
            }
        }

        // --- Global Graph Instance ---
        const flightGraph = new Graph_M();
        flightGraph.createFlightMap();

        // --- UI Initialization and Interaction ---
        const sourceAirportSelect = document.getElementById('sourceAirport');
        const destinationAirportSelect = document.getElementById('destinationAirport');
        const outputDiv = document.getElementById('output');

        function populateAirportSelects() {
            const airports = Array.from(flightGraph.vtces.keys()).sort(); // Sort alphabetically
            airports.forEach(airport => {
                const option1 = document.createElement('option');
                option1.value = airport;
                option1.textContent = airport;
                sourceAirportSelect.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = airport;
                option2.textContent = airport;
                destinationAirportSelect.appendChild(option2);
            });
        }

        function getSelectedAirports() {
            const source = sourceAirportSelect.value;
            const destination = destinationAirportSelect.value;

            if (!source || !destination) {
                outputDiv.textContent = "Please select both source and destination airports.";
                return null;
            }
            if (!flightGraph.vtces.has(source) || !flightGraph.vtces.has(destination)) {
                outputDiv.textContent = "Selected airport(s) not found in the map. This should not happen.";
                return null;
            }
            return { source, destination };
        }

        function runPathfinding(isTimeCost, getPathDetails) {
            const airports = getSelectedAirports();
            if (!airports) return;

            const { source, destination } = airports;
            let result;

            // Simple path existence check (DFS style, as in Java code)
            const hasPath = (src, des, visited = new Set()) => {
                if (src === des) return true;
                visited.add(src);
                const vertex = flightGraph.vtces.get(src);
                if (!vertex) return false; // Should not happen
                for (let nbr of vertex.nbrs.keys()) {
                    if (!visited.has(nbr)) {
                        if (hasPath(nbr, des, visited)) {
                            return true;
                        }
                    }
                }
                return false;
            };

            if (!hasPath(source, destination)) {
                 outputDiv.textContent = `NO PATH EXISTS BETWEEN ${source} AND ${destination}.`;
                 return;
            }

            // Run Dijkstra
            const rawResult = flightGraph.dijkstra(source, destination, isTimeCost);

            if (rawResult.totalCost === -1 || rawResult.path === "NO_PATH" || rawResult.path === "INVALID_STATIONS") {
                outputDiv.textContent = `Could not calculate path. Error: ${rawResult.path}`;
                return;
            }

            if (getPathDetails) {
                result = flightGraph.processPathForDisplay(rawResult);
                if (result.path === "PATH_FORMAT_ERROR") {
                    outputDiv.textContent = "Error processing path for display. Malformed airport name detected.";
                    return;
                }
                let outputStr = `SOURCE AIRPORT: ${source}\n`;
                outputStr += `DESTINATION AIRPORT: ${destination}\n`;
                if (isTimeCost) {
                    outputStr += `TOTAL TIME: ${Math.ceil(result.totalCost / 60)} MINUTES\n`;
                } else {
                    outputStr += `TOTAL DISTANCE: ${result.totalCost} KM\n`;
                }
                outputStr += `NUMBER OF INTERCHANGES: ${result.interchangeCount}\n`;
                outputStr += `~~~~~~~~~~~~~\n${result.path}\n~~~~~~~~~~~~~`;
                outputDiv.textContent = outputStr;
            } else {
                if (isTimeCost) {
                    outputDiv.textContent = `SHORTEST TIME FROM ${source} TO ${destination} IS ${Math.ceil(rawResult.totalCost / 60)} MINUTES`;
                } else {
                    outputDiv.textContent = `SHORTEST DISTANCE FROM ${source} TO ${destination} IS ${rawResult.totalCost} KM`;
                }
            }
        }

        // --- Button Click Handlers ---
        function getShortestDistanceValue() {
            runPathfinding(false, false);
        }

        function getShortestTimeValue() {
            runPathfinding(true, false);
        }

        function getShortestDistancePath() {
            runPathfinding(false, true);
        }

        function getShortestTimePath() {
            runPathfinding(true, true);
        }

        function displayAllAirports() {
            outputDiv.textContent = flightGraph.displayStations();
        }

        function displayMap() {
            outputDiv.textContent = flightGraph.displayMap();
        }

        // Initialize selects on page load
        document.addEventListener('DOMContentLoaded', populateAirportSelects);
    </script>
</body>
</html>